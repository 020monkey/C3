#include "StdAfx.h"
#include "ByteView.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
std::vector<std::string> MWR::SplitAndCopy(std::string_view stringToBeSplitted, std::string_view delimiter)
{
	return Split<true>(stringToBeSplitted, delimiter);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView::ByteView(ByteVector const& data, size_t offset)
	: Super([&]() { return data.size() >= offset ? data.data() + offset : throw std::out_of_range{ OBF("Out of range. Data size: ") + std::to_string(data.size()) + OBF(" offset: ") + std::to_string(offset) }; }(), data.size() - offset)
{

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView::ByteView(ByteVector::const_iterator begin, ByteVector::const_iterator end)
	: Super([&]() { return end >= begin ? begin._Ptr : throw std::out_of_range{ OBF("Out of range by: ") + std::to_string(begin - end) + OBF(" elements.") }; }(), static_cast<size_t>(end - begin))
{

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView::ByteView(std::basic_string_view<ByteVector::value_type> basicSring)
	: Super(basicSring)
{

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView::ByteView(std::string_view data)
	: Super{ reinterpret_cast<const ByteVector::value_type*>(data.data()), data.size() }
{
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView::operator MWR::ByteView::Super() const noexcept
{
	return Super{ data(), size() };
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView::operator MWR::ByteVector() const
{
	return { begin(), end() };
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView::operator std::string() const
{
	return { reinterpret_cast<const char*>(data()), size() };
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView::operator std::string_view() const
{
	return { reinterpret_cast<const char*>(data()), size() };
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector MWR::ByteView::Read(size_t byteCount)
{
	if (byteCount > size())
		throw std::out_of_range{ OBF(": Size: ") + std::to_string(size()) + OBF(". Cannot read ") + std::to_string(byteCount) + OBF(" bytes.") };

	auto retVal = ByteVector{ begin(), begin() + byteCount };
	remove_prefix(byteCount);
	return retVal;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView MWR::ByteView::SubString(const size_type offset, size_type count) const
{
	return Super::substr(offset, count);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView MWR::Literals::operator "" _bv(const char* data, size_t size)
{
	return { reinterpret_cast<const uint8_t*>(data), size };
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteView MWR::Literals::operator "" _bv(const wchar_t* data, size_t size)
{
	return { reinterpret_cast<const uint8_t*>(data), size * sizeof(wchar_t) };
}
